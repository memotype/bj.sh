bj.sh is a pure GNU Bash library for parsing JSON data.\n\nbj.sh is meant to be run as a script, sourced as a library, or copied directly\nin to your script for maximum flexibility. Great for embedded systems, build\nautomation, or any environment where 'jq' isn't available (Plus, bj.sh is 1/20th\nthe size of the 'jq' binary)\n\nbj.sh is *NOT* a JSON validator, behavior is undefined if given invalid JSON!\nIt will detect some basic JSON errors, but this is not the goal of bj.sh.\n\nThe entire parser is implemented as a single bash function, so it can be\n`source`d in to your own script, or you can just copy and paste the function in\nto your script to reduce your external dependencies. `bj-80x13.sh` (80-character\nlines, 13 lines long) and `bj-90x12.sh` (90-character lines, 12 lines long)\nversions are intended for exactly this.\n\n### Usage\n\nCalled as an external script:\n\n    bj.sh [DATA] [QUERY ...]\n\n\nSourced or copied in to your script:\n\n    source bj.sh\n    bj [DATA] [QUERY ...]\n\nDATA can be a JSON string, or `-`. If DATA is `-`, JSON data is read\nfrom stdin.\n\nQUERY terms are the keys and indexes you want to query from the JSON data.\n\n### Examples\n\n    source bj.sh\n    r=$(bj '{"foo": {"bar": "baz"}}' foo bar)\n\n`r` will be set to the string `baz`.\n\n    r=$(curl https://myapi.example.com/api/call | bj - nodes 0)\n\nAssuming the api call returns something like `{"nodes": ["node0", "node1"]}`,\nthis will set `r` to `node0`. To get the list of nodes and iterate over them:\n\n    nodes=$(curl https://myapi.example.com/api/call | bj - nodes)\n    i=0\n    while node=$(bj "$nodes" "$i"); do\n        ping -c1 "$node"\n        (( i++ ))\n    done\n\n`bj` will return the JSON data at the key if it's not a leaf node, so the first\ncall returns `["node0", "node1"]`. Also, `bj` will exit with a code of 1 if the\nqueried key or index doesn't exist. So, when `$i` is `2`, `bj` will return 1,\nbreaking out of the `while` loop.\n